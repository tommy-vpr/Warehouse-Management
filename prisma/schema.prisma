// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ---------------------------------------------------
// üì¶ Core Models
// ---------------------------------------------------
model WorkTask {
  id         String         @id @default(cuid())
  taskNumber String         @unique
  type       WorkTaskType // ‚Üê Updated
  status     WorkTaskStatus @default(PENDING) // ‚Üê Updated

  assignedTo  String?
  assignedAt  DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  orderIds        String[]
  totalOrders     Int
  completedOrders Int      @default(0)

  totalItems     Int
  completedItems Int @default(0)

  priority Int     @default(0)
  notes    String?

  parentTaskId  String?
  parentTask    WorkTask?  @relation("TaskContinuation", fields: [parentTaskId], references: [id])
  continuations WorkTask[] @relation("TaskContinuation")

  assignedUser User?       @relation(fields: [assignedTo], references: [id])
  taskItems    TaskItem[]
  events       TaskEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, status])
  @@index([assignedTo])
  @@map("work_tasks")
}

model TaskItem {
  id               String  @id @default(cuid())
  taskId           String
  orderId          String
  productVariantId String?
  locationId       String?

  quantityRequired  Int
  quantityCompleted Int @default(0)

  status   WorkTaskItemStatus @default(PENDING) // ‚Üê Updated
  sequence Int

  completedBy String?
  completedAt DateTime?
  notes       String?

  task            WorkTask        @relation(fields: [taskId], references: [id], onDelete: Cascade)
  order           Order           @relation(fields: [orderId], references: [id])
  productVariant  ProductVariant? @relation(fields: [productVariantId], references: [id])
  location        Location?       @relation(fields: [locationId], references: [id])
  completedByUser User?           @relation(fields: [completedBy], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([taskId])
  @@index([orderId])
  @@map("task_items")
}

model TaskEvent {
  id        String            @id @default(cuid())
  taskId    String
  eventType WorkTaskEventType // ‚Üê Updated
  userId    String
  data      Json?
  notes     String?
  createdAt DateTime          @default(now())

  task WorkTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id])

  @@index([taskId])
  @@map("task_events")
}

enum WorkTaskType {
  PICKING
  PACKING
  SHIPPING
  QC
}

enum WorkTaskStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  PAUSED
  PARTIALLY_COMPLETED
  COMPLETED
  CANCELLED
}

enum WorkTaskItemStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
  ISSUE
}

enum WorkTaskEventType {
  TASK_CREATED
  TASK_ASSIGNED
  TASK_STARTED
  TASK_PAUSED
  TASK_RESUMED
  ITEM_COMPLETED
  ITEM_SKIPPED
  TASK_COMPLETED
  TASK_CANCELLED
  TASK_REASSIGNED
  TASK_SPLIT

  LABEL_GENERATED
  LABEL_PRINTED
  LABEL_VOIDED
  PACKAGE_WEIGHED
  PACKAGE_DIMENSIONS_RECORDED
  CARRIER_SELECTED
  SERVICE_LEVEL_SELECTED
  RATE_SHOPPED
  INSURANCE_ADDED
  SIGNATURE_REQUIRED
  TRACKING_NUMBER_ASSIGNED
  SHIPMENT_MANIFESTED
  PICKUP_SCHEDULED
  PACKAGE_SCANNED
  SHIPMENT_VOIDED
  CUSTOMS_FORM_CREATED
  HAZMAT_DECLARED
}

// Authentication Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          UserRole  @default(STAFF)

  currentChallenge String?

  accounts    Account[]
  sessions    Session[]
  credentials UserCredential[]

  notifications Notification[]

  receivingSessionsCounted  ReceivingSession[] @relation("CountedBy")
  receivingSessionsApproved ReceivingSession[] @relation("ApprovedBy")

  inventoryTransactions InventoryTransaction[]
  assignedPickLists     PickList[]
  pickedItems           PickListItem[]
  pickEvents            PickEvent[]            @relation("PickEventUser")

  pickEventsAsFromUser PickEvent[] @relation("PickEventFromUser")
  pickEventsAsToUser   PickEvent[] @relation("PickEventToUser")

  statusChanges      OrderStatusHistory[]
  assignedCountTasks CycleCountTask[]
  countEvents        CycleCountEvent[]

  pickingOrders  Order[] @relation("PickingOrders")
  packingOrders  Order[] @relation("PackingOrders")
  shippingOrders Order[] @relation("ShippingOrders")

  assignedTasks      WorkTask[]
  completedTaskItems TaskItem[]
  taskEvents         TaskEvent[]

  printedBarcodes POBarcode[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model UserCredential {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // WebAuthn-specific fields
  credentialId String   @unique // base64url ID of the passkey
  publicKey    String // base64-encoded public key
  counter      Int // used to prevent replay attacks
  transports   String? // "usb,nfc,ble,internal"
  deviceType   String? // "singleDevice" | "multiDevice"
  backedUp     Boolean? // if authenticator supports backup

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UserRole {
  ADMIN
  MANAGER
  STAFF
  READONLY
}

// Products & Inventory
model Product {
  id               String  @id @default(cuid())
  sku              String  @unique
  name             String
  description      String?
  shopifyProductId String? @unique

  // Enhanced product fields
  brand       String?
  category    String?
  productLine String? // "Skwezed ICE", "Skwezed Salt", etc.
  flavor      String? // "Banana", "Blue Razz", etc.

  variants  ProductVariant[]
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([brand])
  @@index([category])
  @@index([productLine])
  @@index([flavor])
  @@map("products")
}

model ProductVariant {
  id        String  @id @default(cuid())
  productId String
  sku       String  @unique
  upc       String? @unique
  name      String

  // Pricing
  costPrice    Decimal? @db.Decimal(10, 2)
  sellingPrice Decimal? @db.Decimal(10, 2)

  // Physical characteristics (single unit)
  weight     Decimal? @db.Decimal(8, 2) // Weight in grams
  dimensions Json? // Enhanced JSON with unit + master case data

  // Product specifications
  volume   String? // "100ml", "30ml"
  strength String? // "00mg", "03mg", "06mg", "25mg", "50mg"

  // Master Case Information
  masterCaseQty        Int? // Quantity per master case (usually 100)
  masterCaseWeight     Decimal? @db.Decimal(8, 2) // MC weight in grams
  masterCaseDimensions Json? // MC dimensions object

  // Enhanced variant attributes
  hasIce         Boolean @default(false)
  hasSalt        Boolean @default(false)
  isNicotineFree Boolean @default(false)
  flavor         String? // Extracted flavor
  productLine    String? // Product line for this variant

  // Existing fields
  shopifyVariantId String? @unique
  category         String?
  supplier         String?
  barcode          String?

  // Back orders
  backOrders   BackOrder[]
  reservations InventoryReservation[]

  // Relations
  product               Product                @relation(fields: [productId], references: [id])
  inventory             Inventory[]
  orderItems            OrderItem[]
  inventoryTransactions InventoryTransaction[]
  pickListItems         PickListItem[]
  countTasks            CycleCountTask[]
  purchaseOrderItems    PurchaseOrderItem[]

  taskItems TaskItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([volume])
  @@index([strength])
  @@index([hasIce])
  @@index([hasSalt])
  @@index([flavor])
  @@index([productLine])
  @@index([upc])
  @@index([barcode])
  @@map("product_variants")
}

model Location {
  id   String @id @default(cuid())
  name String @unique // "1-A-2-B-2-X" format

  // Enhanced location fields
  warehouseNumber Int? // WH column (1, 2, 3, etc.)
  aisle           String? // AISLE column (A, B, C, etc.)
  bay             Int? // BAY column (1, 2, 3, etc.)
  tier            String? // TIER column (A, B, C, etc.)
  space           Int? // SPACE column (1, 2, 3, etc.)
  bin             String? // BIN column (X, Y, Z, etc.)
  barcode         String? @unique // Barcode for scanning

  taskItems TaskItem[]

  // Existing fields
  type         LocationType @default(GENERAL)
  zone         String?
  shelf        String? // Legacy field, can be deprecated
  isPickable   Boolean      @default(true)
  isReceivable Boolean      @default(true)

  // Relations
  inventory             Inventory[]
  inventoryTransactions InventoryTransaction[]
  pickListItems         PickListItem[]
  countTasks            CycleCountTask[]
  reservations          InventoryReservation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([warehouseNumber, aisle, bay, tier, space, bin])
  @@index([warehouseNumber, aisle])
  @@index([barcode])
  @@index([type])
  @@map("locations")
}

enum LocationType {
  RECEIVING
  STORAGE
  PICKING
  PACKING
  SHIPPING
  RETURNS
  GENERAL
}

model Inventory {
  id               String @id @default(cuid())
  productVariantId String
  locationId       String

  // Unit-level inventory
  quantityOnHand   Int @default(0)
  quantityReserved Int @default(0)

  // Case-level inventory (optional)
  casesOnHand   Int? @default(0) // Full cases available
  casesReserved Int? @default(0) // Full cases reserved

  reorderPoint Int?
  maxQuantity  Int?
  lastCounted  DateTime?

  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])
  location       Location       @relation(fields: [locationId], references: [id])
  updatedAt      DateTime       @updatedAt

  @@unique([productVariantId, locationId])
  @@map("inventory")
}

// Order Management
model Order {
  id              String      @id @default(cuid())
  shopifyOrderId  String?     @unique
  orderNumber     String      @unique
  customerName    String
  customerEmail   String?
  status          OrderStatus @default(PENDING)
  totalAmount     Decimal     @db.Decimal(10, 2)
  shippingAddress Json
  billingAddress  Json?

  // Shipping fields
  trackingNumber  String?
  trackingUrl     String?
  shippedAt       DateTime?
  shippingStatus  String?
  shippingCost    String? // Store as string to preserve decimal precision
  shippingCarrier String? // usps, fedex, ups, etc.
  shippingService String? // usps_ground_advantage, fedex_ground, etc.
  labelUrl        String? // Direct link to shipping label
  notes           String? // Packing/shipping notes

  taskItems TaskItem[]

  shopifyFulfillmentIds String?
  shopifyLineItems      Json?

  // Back order
  hasBackOrders Boolean     @default(false)
  backOrders    BackOrder[]

  images OrderImage[]

  currentStage       OrderStage? @default(PICKING)
  pickingAssignedTo  String?
  packingAssignedTo  String?
  shippingAssignedTo String?
  pickingAssignedAt  DateTime?
  packingAssignedAt  DateTime?
  shippingAssignedAt DateTime?

  // Relations
  items         OrderItem[]
  pickListItems PickListItem[]
  packages      ShippingPackage[]
  statusHistory OrderStatusHistory[]

  reservations InventoryReservation[]
  shopifySyncs ShopifySync[]

  pickingUser  User? @relation("PickingOrders", fields: [pickingAssignedTo], references: [id])
  packingUser  User? @relation("PackingOrders", fields: [packingAssignedTo], references: [id])
  shippingUser User? @relation("ShippingOrders", fields: [shippingAssignedTo], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

enum OrderStage {
  PICKING
  PACKING
  SHIPPING
  COMPLETED
}

model OrderImage {
  id        String   @id @default(cuid())
  orderId   String
  url       String
  reference String?
  createdAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@map("order_images")
}

model InventoryReservation {
  id               String            @id @default(cuid())
  orderId          String
  productVariantId String
  locationId       String
  quantity         Int
  status           ReservationStatus @default(ACTIVE)

  // Relations
  order          Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])
  location       Location       @relation(fields: [locationId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orderId, productVariantId, locationId])
  @@index([orderId])
  @@index([productVariantId, locationId])
  @@map("inventory_reservations")
}

enum ReservationStatus {
  ACTIVE
  FULFILLED
  CANCELLED
}

model OrderStatusHistory {
  id             String      @id @default(cuid())
  orderId        String
  previousStatus OrderStatus
  newStatus      OrderStatus
  changedBy      String
  changedAt      DateTime    @default(now())
  notes          String?

  order         Order @relation(fields: [orderId], references: [id])
  changedByUser User  @relation(fields: [changedBy], references: [id])

  @@map("order_status_history")
}

model OrderItem {
  id               String @id @default(cuid())
  orderId          String
  productVariantId String

  quantity       Int
  quantityPicked Int? @default(0) // ‚úÖ actual picked quantity
  quantityPacked Int? @default(0) // ‚úÖ actual packed quantity

  unitPrice  Decimal @db.Decimal(10, 2)
  totalPrice Decimal @db.Decimal(10, 2)

  shopifyLineItemId                 String?
  shopifyFulfillmentOrderLineItemId String?

  order          Order          @relation(fields: [orderId], references: [id])
  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])
  pickListItems  PickListItem[]

  @@map("order_items")
}

model ShopifySync {
  id          String    @id @default(cuid())
  orderId     String
  syncType    String // "FULFILLMENT", "CANCELLATION", "REFUND", etc.
  status      String // "PENDING", "COMPLETED", "FAILED"
  attempts    Int       @default(0)
  data        Json // Store sync details (tracking, items, etc.)
  error       String?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([status, syncType])
  @@map("shopify_syncs")
}

enum OrderStatus {
  PENDING
  ALLOCATED
  PICKING
  PARTIALLY_PICKED
  PICKED
  PACKED
  SHIPPED
  PARTIALLY_SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  FULFILLED
  BACKORDER
}

// Activity Tracking
enum TransactionType {
  ADJUSTMENT
  RECEIPT
  SALE
  TRANSFER
  COUNT
  ALLOCATION
  DEALLOCATION
  PO_RECEIVING // Purchase Order from Supplier
  ASN_RECEIVING // Advanced Ship Notice from Supplier
  TRANSFER_RECEIVING // Inter-warehouse transfer
  RETURNS
}

model InventoryTransaction {
  id               String          @id @default(cuid())
  productVariantId String
  locationId       String?
  transactionType  TransactionType
  quantityChange   Int

  // Enhanced reference tracking
  referenceId    String? // PO ID, Transfer ID, Order ID, etc.
  referenceType  String? // "PURCHASE_ORDER", "TRANSFER", "RETURN_ORDER"
  sourceLocation String? // For transfers (which warehouse it came from)

  userId   String?
  notes    String?
  metadata Json?

  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])
  location       Location?      @relation(fields: [locationId], references: [id])
  user           User?          @relation(fields: [userId], references: [id])
  createdAt      DateTime       @default(now())

  @@index([productVariantId])
  @@index([locationId])
  @@index([userId])
  @@index([referenceType])
  @@map("inventory_transactions")
}

// ---------------------------------------------------
// ***Notification
// ---------------------------------------------------

model Notification {
  id       String  @id @default(cuid())
  userId   String
  type     String // RECOUNT_ASSIGNED, CAMPAIGN_STARTED, etc.
  title    String
  message  String
  link     String?
  read     Boolean @default(false)
  metadata Json?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId, read])
  @@map("notifications")
}

// ---------------------------------------------------
// üöö Picking System Models
// ---------------------------------------------------

model PickList {
  id          String     @id @default(cuid())
  batchNumber String     @unique
  status      PickStatus @default(PENDING)
  assignedTo  String? // User ID of assigned picker
  priority    Int        @default(0)
  totalItems  Int
  pickedItems Int        @default(0)
  startTime   DateTime?
  endTime     DateTime?
  notes       String?

  parentPickListId String?
  parentPickList   PickList?  @relation("PickListContinuation", fields: [parentPickListId], references: [id])
  continuations    PickList[] @relation("PickListContinuation")

  // Relations
  items        PickListItem[]
  events       PickEvent[]
  assignedUser User?          @relation(fields: [assignedTo], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("pick_lists")
}

model PickListItem {
  id               String         @id @default(cuid())
  pickListId       String
  orderId          String
  orderItemId      String?
  productVariantId String
  locationId       String
  quantityToPick   Int
  quantityPicked   Int            @default(0)
  pickSequence     Int // Order to pick items (route optimization)
  status           PickItemStatus @default(PENDING)
  pickedAt         DateTime?
  pickedBy         String? // User ID who picked this item
  shortPickReason  String? // Reason if short picked
  notes            String?

  // Relations
  pickList       PickList       @relation(fields: [pickListId], references: [id], onDelete: Cascade)
  order          Order          @relation(fields: [orderId], references: [id])
  orderItem      OrderItem?     @relation(fields: [orderItemId], references: [id])
  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])
  location       Location       @relation(fields: [locationId], references: [id])
  picker         User?          @relation(fields: [pickedBy], references: [id])

  @@unique([pickListId, orderId, productVariantId, locationId])
  @@map("pick_list_items")
}

model PickEvent {
  id          String        @id @default(cuid())
  pickListId  String
  itemId      String? // PickListItem ID (optional for list-level events)
  eventType   PickEventType
  userId      String
  fromUserId  String? // ‚úÖ NEW: User reassigned FROM
  toUserId    String? // ‚úÖ NEW: User reassigned TO
  location    String? // Location code scanned
  scannedCode String? // Barcode scanned
  data        Json? // Additional event data
  notes       String?
  createdAt   DateTime      @default(now())

  // Relations
  pickList PickList @relation(fields: [pickListId], references: [id], onDelete: Cascade)
  user     User     @relation("PickEventUser", fields: [userId], references: [id])
  fromUser User?    @relation("PickEventFromUser", fields: [fromUserId], references: [id])
  toUser   User?    @relation("PickEventToUser", fields: [toUserId], references: [id])

  @@map("pick_events")
}

enum PickStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  PAUSED
  PARTIALLY_COMPLETED
  COMPLETED
  CANCELLED
}

enum PickItemStatus {
  PENDING
  PICKED
  SHORT_PICK
  SKIPPED
  DAMAGED
}

enum PickEventType {
  PICK_STARTED
  PICK_PAUSED
  PICK_RESUMED
  ITEM_PICKED
  ITEM_SHORT_PICKED
  ITEM_SKIPPED
  LOCATION_SCANNED
  BARCODE_SCANNED
  PICK_COMPLETED
  PICK_CANCELLED
  ERROR_OCCURRED
  PICK_REASSIGNED
  PICK_SPLIT
  PARTIAL_COMPLETION
}

// ---------------------------------------------------
// üöö Shipping System Models
// ---------------------------------------------------

model ShippingPackage {
  id             String   @id @default(cuid())
  orderId        String
  carrierCode    String
  serviceCode    String
  packageCode    String?
  trackingNumber String
  labelUrl       String
  cost           Decimal  @db.Decimal(10, 2)
  currency       String
  weight         Decimal? @db.Decimal(8, 2)
  dimensions     Json?

  items      PackageItem[]
  backOrders BackOrder[]

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("shipping_packages")
}

model PackageItem {
  id          String  @id @default(cuid())
  packageId   String
  productName String
  sku         String
  quantity    Int
  unitPrice   Decimal @db.Decimal(10, 2)

  package ShippingPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("package_items")
}

// ---------------------------------------------------
// üìä Cycle Counting System Models
// ---------------------------------------------------

model CycleCountCampaign {
  id          String          @id @default(cuid())
  name        String
  description String?
  countType   CycleCountType
  status      CampaignStatus  @default(PLANNED)
  startDate   DateTime
  endDate     DateTime?
  frequency   CountFrequency? // For recurring campaigns

  // Criteria for what to count
  locationIds       String[] // Specific locations to count
  zoneFilter        String? // Count by zone
  abcClass          String? // Count by ABC classification
  lastCountedBefore DateTime? // Items not counted since this date

  // Progress tracking
  totalTasks     Int @default(0)
  completedTasks Int @default(0)
  variancesFound Int @default(0)

  // Relations
  tasks      CycleCountTask[]
  createdBy  String
  assignedTo String[] // User IDs who can perform counts

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("cycle_count_campaigns")
}

model CycleCountTask {
  id               String  @id @default(cuid())
  campaignId       String? // Optional - for ad-hoc counts
  locationId       String
  productVariantId String? // null for location counts

  // Task details
  taskNumber String               @unique
  priority   Int                  @default(0)
  status     CycleCountTaskStatus @default(PENDING)
  countType  CycleCountType

  // Expected vs actual counts
  systemQuantity     Int // What system says
  countedQuantity    Int? // What was actually counted
  variance           Int? // Difference (counted - system)
  variancePercentage Decimal? @db.Decimal(5, 2)

  // Assignment and timing
  assignedTo  String? // User ID
  assignedAt  DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  // Additional details
  notes               String?
  tolerancePercentage Decimal? @default(5.0) @db.Decimal(5, 2)
  requiresRecount     Boolean  @default(false)
  recountReason       String?

  // Relations
  campaign       CycleCountCampaign? @relation(fields: [campaignId], references: [id])
  location       Location            @relation(fields: [locationId], references: [id])
  productVariant ProductVariant?     @relation(fields: [productVariantId], references: [id])
  assignedUser   User?               @relation(fields: [assignedTo], references: [id])
  events         CycleCountEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([campaignId, locationId, productVariantId]) // Prevent duplicate tasks
  @@map("cycle_count_tasks")
}

model CycleCountEvent {
  id        String         @id @default(cuid())
  taskId    String
  eventType CountEventType
  userId    String

  // Event data
  previousValue Int? // Previous quantity
  newValue      Int? // New quantity
  notes         String?
  metadata      Json? // Additional event data

  // Relations
  task CycleCountTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User           @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@map("cycle_count_events")
}

enum CycleCountType {
  FULL // Count everything
  PARTIAL // Count specific items/locations
  ABC_ANALYSIS // Count based on ABC classification
  FAST_MOVING // High-velocity items
  SLOW_MOVING // Low-velocity items
  NEGATIVE_STOCK // Items with negative quantities
  ZERO_STOCK // Items showing zero quantity
  HIGH_VALUE // High-dollar-value items
  DAMAGED_LOCATION // Specific location audit
}

enum CampaignStatus {
  PLANNED
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum CycleCountTaskStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  COMPLETED
  VARIANCE_REVIEW
  RECOUNT_REQUIRED
  SKIPPED
  CANCELLED
}

enum CountEventType {
  TASK_CREATED
  TASK_ASSIGNED
  COUNT_STARTED
  COUNT_RECORDED
  COUNT_SKIPPED
  VARIANCE_NOTED
  RECOUNT_REQUESTED
  TASK_COMPLETED
  TASK_CANCELLED
  NOTE_ADDED
}

enum CountFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  ANNUALLY
  AD_HOC
}

model PurchaseOrder {
  id           String    @id @default(cuid())
  poNumber     String    @unique // e.g. "PO-202509-226"
  supplier     String
  status       String    @default("DRAFT") // or enum
  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  totalAmount  Decimal   @db.Decimal(10, 2)

  // Relations
  items     PurchaseOrderItem[]
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id               String  @id @default(cuid())
  purchaseOrderId  String
  productVariantId String
  quantity         Int
  unitCost         Decimal @db.Decimal(10, 2)
  totalCost        Decimal @db.Decimal(10, 2)

  purchaseOrder  PurchaseOrder  @relation(fields: [purchaseOrderId], references: [id])
  productVariant ProductVariant @relation(fields: [productVariantId], references: [id])

  @@map("purchase_order_items")
}

// ---------------------------------------------------
// *** Inventory Planner
// ---------------------------------------------------
model ForecastSuggestion {
  id             String    @id @default(cuid())
  sku            String    @unique
  productName    String?
  vendorId       String?
  warehouseId    String?
  currentStock   Int?
  forecast30Days Int?
  forecast60Days Int?
  forecast90Days Int?
  daysOfStock    Int?
  safetyStock    Int?
  leadTimeDays   Int?
  reorderPoint   DateTime?
  recommendedQty Int?
  unitCost       Float?
  currency       String?
  replenishment  Int? // from API
  reviewPeriod   Int? // from API
  lastUpdated    DateTime

  @@index([sku, warehouseId])
}

model InventoryPlannerPurchaseOrder {
  id           String    @id @default(cuid())
  poId         String    @unique
  reference    String?
  vendorId     String?
  vendorName   String?
  status       String
  createdAt    DateTime
  expectedDate DateTime?
  currency     String?
  totalValue   Float?
  lastUpdated  DateTime

  lines InventoryPlannerPOLine[]
}

model InventoryPlannerPOLine {
  id              String  @id @default(cuid())
  purchaseOrderId String
  sku             String
  productName     String?
  qtyOrdered      Int
  unitCost        Float?
  totalCost       Float?

  purchaseOrder InventoryPlannerPurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@index([sku])
}

model SyncProgress {
  id          String   @id @default(cuid())
  type        String   @unique // "forecast" or "purchase_order"
  status      String // "running", "completed", "error"
  progress    Int      @default(0)
  total       Int      @default(0)
  currentPage Int      @default(0)
  message     String
  userId      String?
  startedAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type, status])
}

model SyncLog {
  id     String   @id @default(cuid())
  type   String // "forecast" | "purchase_order"
  status String // "success" | "error"
  count  Int?
  error  String?
  runAt  DateTime @default(now())
}

// ---------------------------------------------------
// ***BackOrder System Models
// ---------------------------------------------------

model BackOrder {
  id                String  @id @default(cuid())
  orderId           String
  productVariantId  String
  shippingPackageId String?

  // Quantities
  quantityBackOrdered Int // Total backordered
  quantityFulfilled   Int @default(0)

  // Status & tracking
  status        BackOrderStatus @default(PENDING)
  reason        BackOrderReason
  reasonDetails String?
  priority      Int             @default(0)

  // Context (where backorder originated)
  createdDuring          String // "ORDER_ALLOCATION" | "PICKING"
  originalPickListItemId String? // Only if created during picking

  // Dates
  createdAt   DateTime  @default(now())
  fulfilledAt DateTime?

  // Relations
  order           Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productVariant  ProductVariant   @relation(fields: [productVariantId], references: [id])
  shippingPackage ShippingPackage? @relation(fields: [shippingPackageId], references: [id]) // ‚úÖ NEW

  updatedAt DateTime @updatedAt

  @@unique([orderId, productVariantId])
  @@index([status])
  @@index([productVariantId, status])
  @@index([shippingPackageId])
  @@map("back_orders")
}

enum BackOrderStatus {
  PENDING // Waiting for inventory
  ALLOCATED // Inventory reserved
  PICKING // ‚úÖ Being picked
  PICKED // ‚úÖ Picked from warehouse
  PACKED // ‚úÖ Packed in box
  FULFILLED // Shipped to customer
  CANCELLED // Cancelled
}

enum BackOrderReason {
  INSUFFICIENT_STOCK_AT_ALLOCATION // ‚Üê Created during order allocation
  SHORT_PICK // ‚Üê Created during picking
  ITEM_SKIPPED // ‚Üê Created when picker skips
  DAMAGED_PRODUCT
  LOCATION_EMPTY
  OTHER
}

// ---------------------------------------------------
// ***Receiving
// ---------------------------------------------------

model ReceivingSession {
  id          String          @id @default(cuid())
  poId        String
  poReference String
  vendor      String?
  status      ReceivingStatus @default(PENDING)

  // Counting user
  countedBy     String
  countedByUser User     @relation("CountedBy", fields: [countedBy], references: [id])
  countedAt     DateTime @default(now())

  // Approval
  approvedBy      String?
  approvedByUser  User?     @relation("ApprovedBy", fields: [approvedBy], references: [id])
  approvedAt      DateTime?
  rejectionReason String?

  // Line items
  lineItems ReceivingLine[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([poId])
  @@index([status])
  @@index([countedBy])
  @@map("receiving_sessions")
}

model ReceivingLine {
  id               String @id @default(cuid())
  sessionId        String
  sku              String
  productName      String
  quantityCounted  Int
  quantityExpected Int?
  variance         Int? // counted - expected

  session ReceivingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("receiving_lines")
}

enum ReceivingStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

model POBarcode {
  id String @id @default(cuid())

  // PO Information
  poId        String @unique
  poReference String
  vendorName  String

  // Barcode
  barcodeValue String @unique
  barcodeType  String @default("CODE128")

  // Tracking
  printedCount      Int       @default(0)
  lastPrintedAt     DateTime?
  lastPrintedBy     String?
  lastPrintedByUser User?     @relation(fields: [lastPrintedBy], references: [id])

  scannedCount  Int       @default(0)
  lastScannedAt DateTime?
  lastScannedBy String?

  // Metadata
  expectedItems    Json?
  totalExpectedQty Int?
  status           String @default("ACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([poId])
  @@index([barcodeValue])
  @@index([status])
  @@map("po_barcodes")
}
